\chapter{Специальные операторы}
\label{ch:20}

\thispagestyle{empty}

Между прочим, наиболее впечатляющим аспектом условной системы, описанной в предыдущей
главе, является то, что если бы она не была частью языка, то она могла бы быть полностью
написана в виде отдельной библиотеки.  Это возможно, поскольку специальные операторы
Common Lisp (когда никто не осуществляет прямого доступа к обработке или выдаче условий)
обеспечивают достаточный уровень доступа к низкоуровневым частям языка, что делает
возможным контроль раскрутки стека (unwinding of the stack).

В~предыдущих главах я обсуждал наиболее часто используемые специальные операторы, но было
бы неправильным ознакомиться только с их частью.  Для этого есть две причины~-- во-первых,
некоторые из редко используемых специальных операторов используются редко просто
потому, что то, что они обрабатывают, обычно не используется в большинстве программ.
Ознакомиться с ними будет полезно хотя бы для того, чтобы вы знали, что они существуют.  А
во-вторых, поскольку 25 специальных операторов (вместе с правилами вычисления вызовов
функций и основными типами данных) составляют основу для остальной части языка, то
знакомство с ними поможет вам понять, как язык устроен.

В~этой главе я буду обсуждать специальные операторы (некоторые вкратце, а некоторые~--
более подробно), так что вы сможете увидеть, как они связаны между собой.  Я буду указывать
на те, которые вы сможете напрямую использовать в вашем коде, на те, которые могут служить
основой для конструкций, которые вы будете использовать все время, а также на те, которые
вы будете редко использовать напрямую, но которые вы сможете использовать в коде,
генерируемом макросами.

\section{Контроль вычисления}

К первой категории специальных операторов относятся три оператора, которые обеспечивают
базовый контроль вычисления выражений. Это \lstinline{QUOTE}, \lstinline{IF} и \lstinline{PROGN}, про
которые я уже рассказывал.  Однако было бы неправильным не отметить то, как каждый из этих
специальных операторов предоставляет контроль за вычислением одной или нескольких форм.
\lstinline{QUOTE} предотвращает вычисление выражения и позволяет вам получить s-выражение в
виде данных. \lstinline{IF} реализует базовый оператор логического выбора, на основе которого
могут быть построены все остальные условные выражения\footnote{Конечно, если бы \lstinline{IF}
  не был специальным оператором, а некоторым другим условным выражением, таким как
  \lstinline{COND}, то вы могли бы реализовать \lstinline{IF} в виде макроса.  На самом деле во
  многих диалектах Lisp, начиная с оригинального Lisp McCarthy, \lstinline{COND} был
  примитивным условным оператором.}\hspace{\footnotenegspace}.  А~\lstinline{PROGN} обеспечивает возможность вычисления
последовательности выражений.

\section{Манипуляции с лексическим окружением}

Наибольший класс специальных операторов составляют операторы, которые манипулируют и
производят доступ к лексическому окружению. \lstinline{LET} и \lstinline{LET*}, которые мы уже
обсуждали, являются примерами специальных операторов, которые манипулируют лексическим
окружением, поскольку они вводят новые лексические связи для переменных.  Любая
конструкция, такая как \lstinline{DO} или \lstinline{DOTIMES}, которая связывает лексические
переменные, будет развёрнута в \lstinline{LET} или \lstinline{LET*}\footnote{Конечно, с технической
  точки зрения эти конструкции также будут развёрнуты в \lstinline{LAMBDA}-выражения,
  поскольку, как я упоминял в главе~\ref{ch:06}, \lstinline{LET} может быть определена (и это
делалось в ранних версиях Lisp) в виде макроса, который развёртывается в запуск анонимной
функции.}\hspace{\footnotenegspace}. Специальный оператор \lstinline{SETQ} является одним из операторов для доступа к
лексическому окружению, поскольку он может быть использован для установки значений
переменных, чьи связи были созданы с помощью \lstinline{LET} и \lstinline{LET*}.

Однако не только переменные могут быть поименованы внутри лексического окружения.  Хотя
большинство функций и определены глобально с использованием \lstinline{DEFUN}, но все равно
возможно создание локальных функций с помощью специальных операторов \lstinline{FLET} и
\lstinline{LABELS}, локальных макросов с помощью \lstinline{MACROLET}, а также специальных видов
макросов (называемых символьными макросами) с помощью \lstinline{SYMBOL-MACROLET}.

Точно так же, как и \lstinline{LET} позволяет вам ввести переменную, чьей областью видимости
будет тело \lstinline{LET}, \lstinline{FLET} и \lstinline{LABELS} позволяют вам определить функцию,
которая будет видна только внутри области видимости \lstinline{FLET} или \lstinline{LABELS}.  Эти
специальные операторы являются очень удобными, если вам нужна локальная функция, которая
является слишком сложной для её определения как \lstinline{LAMBDA}, или если вам нужно вызвать
ее несколько раз.  Оба этих оператора имеют одинаковую форму, которая выглядит так:

\begin{myverb}
(flet (function-definition*)
  body-form*)
\end{myverb}

\noindent{}или так:

\begin{myverb}
(labels (function-definition*)
  body-form*)
\end{myverb}

\noindent{}где каждая из \lstinline{function-definition} имеет следующую форму:

\begin{myverb}
(name (parameter*) form*)
\end{myverb}

Разница между \lstinline{FLET} и \lstinline{LABELS} заключается в том, что имена функций, которые
определены с помощью \lstinline{FLET}, могут использоваться только в теле \lstinline{FLET}, в то
время как имена, определённые с помощью \lstinline{LABELS}, могут использоваться сразу, включая
тела функций, определённых с помощью \lstinline{LABELS}. Таким образом, \lstinline{LABELS} может
определять рекурсивные функции, а \lstinline{FLET}~-- не может.  Может показаться ограничением
то, что \lstinline{FLET} не может быть использован для определения рекурсивных функций, но
Common Lisp предоставляет и \lstinline{FLET}, и \lstinline{LABELS} по той причине, что иногда бывает
полезным иметь возможность написать локальную функцию, которая может вызвать другую функцию
с тем же именем, либо глобальную, либо определённую в охватывающей области видимости.

Внутри тела \lstinline{FLET} или \lstinline{LABELS} вы можете использовать имена определённых
функций, точно так же как и имена любых других функций, включая использование со
спе\-циаль\-ным оператором \lstinline{FUNCTION}.  Поскольку вы можете использовать \lstinline{FUNCTION}
для получения объекта-функции, представляющего функцию, определённую с помощью \lstinline{FLET}
или \lstinline{LABELS}, и поскольку \lstinline{FLET} и \lstinline{LABELS} могут быть в области видимости
других связывающих форм, таких как \lstinline{LET}, то эти функции могут использоваться как
замыкания (closures).

Так как локальные функции могут ссылаться на переменные из охватывающего окружения, то
они могут часто записываться таким образом, чтобы принимать меньше параметров, чем
эквивалентные вспомогательные функции.  Это очень удобно, когда вам необходимо в качестве
параметра-функции передать функцию, которая принимает единственный аргумент. Например, в
следующей функции, которую вы увидите снова в главе~\ref{ch:25}, функция
\lstinline{count-version}, определённая с помощью \lstinline{FLET}, принимает единственный аргумент,
как этого требует функция \lstinline{walk-directory}, но она также может использовать
переменную \lstinline{versions}, заданную охватывающим \lstinline{LET}:

\begin{myverb}
(defun count-versions (dir)
  (let ((versions (mapcar #'(lambda (x) (cons x 0)) '(2 3 4))))
    (flet ((count-version (file)
             (incf (cdr (assoc (major-version (read-id3 file)) versions)))))
      (walk-directory dir #'count-version :test #'mp3-p))
    versions))
\end{myverb}

Эта функция также может быть записана с использованием анонимной функции вместо
использования \lstinline{FLET}, но задание имени делает исходный текст более понятным.

И когда вспомогательная функция должна быть рекурсивной, она не может быть
анонимной\pclfootnote{Сюрпризом может показаться то, что в действительности можно сделать
  анонимную функцию рекурсивной.  Однако вы должны будете использовать достаточно
  эзотеричный механизм, известный как <<Y-комбинатор>>.  Но Y-комбинатор является интересным
  теоретическим результатом, а не средством практического программирования, так что мы
  оставим его за пределами данной книги.}.  Когда вам не нужно определять рекурсивную
вспомогательную функцию как глобальную функцию, то вы можете использовать \lstinline{LABELS}.
Например, следующая функция, \lstinline{collect-leaves}, использует рекурсивную вспомогательную
функцию \lstinline{walk} для прохода по дереву и сбора всех объектов дерева в список, который
затем возвращается \lstinline{collect-leaves} (после его реверсирования):

\begin{myverb}
(defun collect-leaves (tree)
  (let ((leaves ()))
    (labels ((walk (tree)
               (cond
                 ((null tree))
                 ((atom tree) (push tree leaves))
                 (t (walk (car tree))
                    (walk (cdr tree))))))
      (walk tree))
    (nreverse leaves)))
\end{myverb}


Снова отметьте, как внутри функции \lstinline{walk} вы можете ссылаться на переменную
\lstinline{leaves}, объявленную окружающим \lstinline{LET}.

\lstinline{FLET} и \lstinline{LABELS} также являются полезными при раскрытии макросов~-- макрос
может раскрываться в код, который содержит \lstinline{FLET} или \lstinline{LABELS} для создания
функций, которые могут быть использованы внутри тела макроса.  Этот приём может быть
использован либо для введения функций, которые будет вызывать пользователь макроса, либо
для организации кода, генерируемого макросом.  Это может служить примером того, как может
быть определена функция, такая как \lstinline{CALL-NEXT-METHOD}, которая может быть
использована только внутри определения метода.

К той же группе, что \lstinline{FLET} и \lstinline{LABELS}, можно отнести специальный оператор
\lstinline{MACROLET}, который вы можете использовать для определения локальных
макросов. Локальные макросы работают так же, как и глобальные макросы, определённые с
помощью \lstinline{DEFMACRO}, за тем исключением, что они не затрагивают глобального
пространства имён.  Когда вычисляется \lstinline{MACROLET}, то выражения в теле вычисляются с
использованием локального определения макроса, которое, возможно, скрывает глобальное
определение, а также используя локальные определения из окружающих выражений.  Подобно
\lstinline{FLET} и \lstinline{LABELS}, \lstinline{MACROLET} может использоваться напрямую, но оно также
очень удобно для использования кодом, сгенерированным макросом,~-- путём обёртки в
\lstinline{MACROLET} некоторого кода, написанного пользователем, макрос может предоставлять
конструкции, которые могут быть использованы только внутри этого кода, или скрывать
глобально определённый макрос.  Вы увидите примеры использования \lstinline{MACROLET} в
главе~\ref{ch:31}.

В~заключение ещё одним специальным оператором для определения макросов является
\lstinline{SYMBOL-MACROLET}, который определяет специальный вид макросов, называемых
символьными макросами (symbol macro).  Символьные макросы аналогичны обычным, за тем
исключением, что они не могут принимать аргументы и их используют как обычный символ, а
не в листовой записи.  Другими словами, после того как вы определили символьный макрос с
некоторым именем, любое использование этого символа как значения будет раскрыто, и вместо
него будет вычислена соответствующая форма.  Это как раз относится к тому, как макросы,
такие как \lstinline{WITH-SLOTS} и \lstinline{WITH-ACCESSORS}, получают возможность определения
<<переменных>>, которые осуществляют доступ к состоянию определённого объекта.  Например,
следующее выражение \lstinline{WITH-SLOTS}:

\begin{myverb}
(with-slots (x y z) foo (list x y z)))
\end{myverb}

\noindent{}может быть раскрыто в код, который использует \lstinline{SYMBOL-MACROLET}:

\begin{myverb}
(let ((#:g149 foo))
  (symbol-macrolet
      ((x (slot-value #:g149 'x))
       (y (slot-value #:g149 'y))
       (z (slot-value #:g149 'z)))
    (list x y z)))
\end{myverb}

Когда вычисляется выражение \lstinline{(list x y z)}, то символы \lstinline{x},
\lstinline{y} и \lstinline{z} будут раскрыты в соответствующие формы, такие как
\lstinline!(slot-value #:g149 'x)!\footnote{\lstinline{WITH-SLOTS} не обязательно должен
  быть реализован с помощью \lstinline{SYMBOL-MACROLET}~-- в некоторых реализациях,
  \lstinline{WITH-SLOTS} может проходить по коду и раскрывать макрос с \lstinline{x},
  \lstinline{y} и \lstinline{z}, уже заменёнными на соответствующие формы
  \lstinline{SLOT-VALUE}.  Вы можете увидеть, как это делает ваша реализация, с помощью
  следующего выражения:

\begin{myverb}
(macroexpand-1 '(with-slots (x y z) obj (list x y z)))
\end{myverb}

Однако реализации Lisp легче выполнить такую подстановку внутри своего кода, чем кода,
написанного пользователем,~-- чтобы заменить \lstinline{x}, \lstinline{y} и \lstinline{z}
только в случаях, когда они используются как значения, проходчик по коду должен понимать
синтаксис всех специальных операторов и уметь рекурсивно раскрывать все макросы, чтобы
определить, включает ли макрос в раскрытой форме эти символы в позиции значения.
Реализации Lisp имеют соответствующий проходчик по коду, но он относится к той части Lisp,
которая недоступна пользователю языка.}\hspace{\footnotenegspace}.

Символьные макросы наиболее часто используются локально и определяются с помощью
\lstinline{SYMBOL-MACROLET}, но Common Lisp также предоставляет макрос
\lstinline{DEFINE-SYMBOL-MACRO}, который определяет глобальный символьный макрос.  Символьный
макрос, определённый с помощью \lstinline{SYMBOL-MACROLET}, скрывает другие макросы с тем же
именем, определённые с помощью \lstinline{DEFINE-SYMBOL-MACRO} или охватывающих выражений
\lstinline{SYMBOL-MACROLET}.

\section{Локальный поток управления}

Следующие четыре специальных оператора, о которых я буду говорить, также создают и
используют имена в лексическом окружении, но для целей изменения контроля потока, а не для
определения новых функций и макросов. Я упоминал ранее все четыре из этих специальных
операторов, потому что они предоставляют низкоуровневые механизмы, используемые для других
особенностей языка. Вот они: \lstinline{BLOCK}, \lstinline{RETURN-FROM}, \lstinline{TAGBODY} и
\lstinline{GO}. Первые два, \lstinline{BLOCK} и \lstinline{RETURN-FROM}, используются вместе для
написания кода, который совершает выход немедленно из секции кода,~-- я говорил про
\lstinline{RETURN-FROM} в главе~\ref{ch:05}, как о способе немедленного выхода из функции, но
он работает и в более общих случаях, чем тот. Два других \lstinline{TAGBODY} и \lstinline{GO},
предоставляют вполне низкоуровневую \textit{goto} конструкцию, которая составляет основу для всех
высокоуровневых конструкций цикла, которые вы уже видели.

Общий скелет формы \lstinline{BLOCK} таков:

\begin{myverb}
(block name
  form*)
\end{myverb}

\noindent{}\textit{name} является символом и \textit{form*}, это формы языка. Формы выполняются по
порядку, и значение последней формы возвращается как значение всего \lstinline{BLOCK}, если не
использован \lstinline{RETURN-FROM} для возврата из блока ранее. \lstinline{RETURN-FROM} форма, как
вы видели в главе~\ref{ch:05}, состоит из имени блока, из которого выходят, и, по желанию, формы,
которая предоставляет возвращаемое значение.  Когда \lstinline{RETURN-FROM} выполняется, это
является причиной немедленного выхода из упомянутого в нём \lstinline{BLOCK}.  Если
\lstinline{RETURN-FROM} вызван с формой, возвращающей значение, \lstinline{BLOCK} вернёт это
значение; в ином случае \lstinline{BLOCK} вернёт \lstinline{NIL}.

Именем для \lstinline{BLOCK} может быть любой символ, включая \lstinline{NIL}. Многие из стандартных
макросов конструкций контроля, таких как \lstinline{DO}, \lstinline{DOTIMES} и \lstinline{DOLIST},
генерируют код, состоящий из \lstinline{BLOCK}, названного \lstinline{NIL}. Это позволяет вам
использовать макрос \lstinline{RETURN}, который, скорее, является синтаксическим сахаром для
\lstinline!(return-from nil ...)!, чтобы прерывать такие циклы. Так, следующий цикл
напечатает не более десяти случайных чисел, остановившись сразу же, как только достигнет
числа, большего, чем~50:

\begin{myverb}
(dotimes (i 10)
  (let ((answer (random 100)))
    (print answer)
    (if (> answer 50) (return))))
\end{myverb}

Задающие функции макросы, такие как \lstinline{DEFUN}, \lstinline{FLET} и \lstinline{LABELS}, с другой
стороны, оборачивают свои тела в \lstinline{BLOCK} с тем же именем, что и функция. Вот почему
вы можете пользоваться \lstinline{RETURN-FROM} для возврата из функции.

\lstinline{TAGBODY} и \lstinline{GO} имеют такое же отношение друг к другу, как \lstinline{BLOCK} и
\lstinline{RETURN-FROM}: \lstinline{TAGBODY} задаёт контекст, в котором определены имена,
используемые \lstinline{GO}. Скелет \lstinline{TAGBODY} следующий:

\begin{myverb}
(tagbody
  tag-or-compound-form*)
\end{myverb}

\noindent{}где каждая \textit{tag-or-compound-form},~-- это или символ, называемый \textit{тег}, или
непустая списочная форма. Форма выполняется по порядку, и теги игнорируются, кроме случая,
о котором я скоро скажу. После выполнения последней формы в \lstinline{TAGBODY} он
возвращает \lstinline{NIL}. В~любом месте внутри лексической области видимости \lstinline{TAGBODY}
вы можете использовать специальный оператор \lstinline{GO} для немедленного перехода на любой
тег, и выполнение продолжится с формы, следующей за тегом. Например, вы можете написать
простейший бесконечный цикл с \lstinline{TAGBODY} и \lstinline{GO} вроде этого:

\begin{myverb}
(tagbody
 top
   (print 'hello)
   (go top))
\end{myverb}

Заметьте, что в то время как имена тегов должны появляться на верхнем уровне в
\lstinline{TAGBODY}, не заключёнными внутри форм, специальный оператор \lstinline{GO} может
появляться где угодно внутри области видимости \lstinline{TAGBODY}. Это означает, что вы можете
написать цикл, который выполняется случайное число раз, например так:

\begin{myverb}
(tagbody
 top
   (print 'hello)
   (when (plusp (random 10)) (go top)))
\end{myverb}

Ещё более глупый пример \lstinline{TAGBODY}, который показывает вам, что можно иметь множество
тегов в одном \lstinline{TAGBODY}, выглядит так:

\begin{myverb}
(tagbody
 a (print 'a) (if (zerop (random 2)) (go c))
 b (print 'b) (if (zerop (random 2)) (go a))
 c (print 'c) (if (zerop (random 2)) (go b)))
\end{myverb}

Эта форма будет прыгать вокруг случайно печатаемых \textit{a}, \textit{b} и \textit{c} до
тех пор, пока \lstinline{RANDOM} не вернёт~1 и управление, наконец, достигнет конца
\lstinline{TAGBODY}.

\lstinline{TAGBODY} редко используется прямо, так как почти всегда удобнее писать итеративные
конструкции в терминах существующих циклических макросов. Однако он становится удобным для
перевода алгоритмов, написанных на других языках, в Common Lisp либо автоматически, либо
вручную. Примером инструмента автоматического перевода является транслятор
FORTRAN-to-Common Lisp, f2cl, который переводит исходный код на Фортране в исходный код
на Common Lisp, для того чтобы сделать различные библиотеки из Фортрана доступными для
программистов на Common Lisp. Так как многие библиотеки Фортрана были написаны до
революции структурного программирования, они полны операторов \textit{goto}. f2cl
транслятор может просто переводить такие \textit{goto} в \lstinline{GO} внутри соответствующих
\lstinline{TAGBODY}\pclfootnote{Одна версия f2cl доступна как часть
  \href{http://clocc.sourceforge.net/}{Common Lisp Open Code Collection (CLOCC)}. Для
  контраста рассмотрим трюки, к которым авторам f2j, FORTRAN-to-Java транслятора
  пришлось прибегнуть. Хотя Java Virtual Machine (JVM) имеет \textit{goto}-инструкцию, она
  не выражена прямо в Java. Таким образом, чтобы скомпилировать все \textit{goto} из
  Фортрана, они сначала компилируют фортран-код в стандартный java-код с вызовами к 
  классу \textit{dummy} для представления меток и \textit{goto}. Затем они компилируют
  исходник обычным java-компилятором и делают постобработку полученного байт-кода для
  перевода вызовов \textit{dummy} в JVM байт-коды. Умно, но болезненно.}.

Аналогично \lstinline{TAGBODY} и \lstinline{GO} могут быть полезны, когда переводятся алгоритмы,
напи\-сан\-ные или прозой, или диаграммами переходов,~-- например, в классической серии
Дональда Кнута <<Искусство программирования>> он описывает алгоритмы, используя формат
<<рецептов>>: 

\begin{myverb}
step 1, do this; 
step 2, do that; 
step 3, go back to step 2;
\end{myverb}

\noindent{}и так далее. Для примера на странице 142 <<Искусства программирования>>, том~2:
<<Получисленные алгоритмы>>, 3-е изд. (Addison-Wesley, 1998), он описывает алгоритм~S,
который вы увидите в главе~\ref{ch:27}, в такой форме:

\textit{Алгоритм~S} (метод выбора последовательности). Для выбора \textit{n} случайных записей из
множества $N$, где $0 < n <= N$.

\begin{description}
\item[S1. (Инициализировать.)] Установить \lstinline!t <-- 0!, \lstinline!m <-- 0!. (В
  этом алгоритме \lstinline!m! представляет количество записей уже выбранных, а \lstinline!t! общее
  количество записей которые мы просмотрели.);

\item[S2. (Сгенерировать U.)]  Сгенерировать случайное число \lstinline!U!, равномерно
  распределённое между нулём и единицей;

\item[S3. (Проверить.)] Если \lstinline!(N - t)U >= n - m!, то перейти к шагу~\textbf{S5};

\item[S4. (Выбрать.)] Выбрать следующую запись в последовательность и увеличить
\lstinline!m! и \lstinline!t! на~1. Если \lstinline!m < n!, то перейти к шагу~\textbf{S2}; иначе 
последовательность закончена и алгоритм завершается;

\item[S5. (Пропустить.)] Пропустить следующую запись (не включать её в 
последовательность), увеличить \lstinline!t! на~1, и вернуться к шагу~\textbf{S2}.

\end{description}

Это описание может быть легко переведено в  функцию Common Lisp после переименования
нескольких переменных таким образом:

\begin{myverb}
(defun algorithm-s (n max) ; max это N в алгоритме Кнута
  (let (seen               ; t в в алгоритме Кнута
        selected           ; m в алгоритме Кнута
        u                  ; U в алгоритме Кнута
        (records ()))      ; список, где мы сохраняем выбранные записи
    (tagbody
     s1
       (setf seen 0)
       (setf selected 0)
     s2
       (setf u (random 1.0))
     s3
       (when (>= (* (- max seen) u) (- n selected)) (go s5))
     s4
       (push seen records)
       (incf selected)
       (incf seen)
       (if (< selected n)
           (go s2)
           (return-from algorithm-s (nreverse records)))
     s5
       (incf seen)
       (go s2))))
\end{myverb}

Это не самый красивый код, но легко проверить, что это канонический перевод алгоритма
Кнута. Однако этот код, в отличие от прозаического описания у Кнута, может быть запущен и
проверен. Затем вы можете начать рефакторинг, проверяя после каждого изменения, что
функция всё ещё работает\footnote{Так как этот алгоритм зависит от значений, возвращаемых
  \lstinline{RANDOM}, вы, может, захотите проверить его с одним и тем же произвольным
  начальным значением (consistent random seed), которое вы можете получить, привязывая
  \lstinline{*RANDOM-STATE*} к значению (make-random-state nil) для каждого вызова
  \lstinline{algorithm-s}. Например, вы можете сделать проверку для
  \lstinline{algorithm-s} путём выполнения следующего кода:

\begin{myverb}
(let ((*random-state* (make-random-state nil))) (algorithm-s 10 200))
\end{myverb}

Если ваша рефакторизация на каждом шаге была правильна, это выражение должно выдавать один
и тот же список каждый раз.}\hspace{\footnotenegspace}.

Сложив все кусочки, вы, возможно, получите что-то наподобие этого:

\begin{myverb}
(defun algorithm-s (n max)
  (loop for seen from 0
     when (< (* (- max seen) (random 1.0)) n)
     collect seen and do (decf n)
     until (zerop n)))
\end{myverb}

Хотя это может быть не очевидно, что этот код правильно представляет \textit{алгоритм~S},
но если вы пришли к нему посредством серии функций, которые вели себя идентично
оригинальному дословному переводу рецепта Кнута, у вас есть хорошее основание верить, что
он правильный.

\section{Раскрутка стека}

Другим интересным аспектом языка является то, что специальные операторы дают вам контроль
за поведением стека вызовов функций. Например, хотя вы обычно используете
\lstinline{BLOCK} и \lstinline{TAGBODY} для управления потоком выполнения команд внутри
отдельной функции, вы также можете использовать их вместе с замыканиями для выполнения
немедленного нелокального выхода из функции в точку, находящуюся ниже на стеке. Это
происходит потому, что имена \lstinline{BLOCK} и теги \lstinline{TAGBODY} могут быть
окружены любым кодом внутри лексического окружения \lstinline{BLOCK} или
\lstinline{TAGBODY}.  Например, рассмотрим следующую функцию:

\begin{myverb}
(defun foo ()
  (format t "Entering foo~%")
  (block a
    (format t " Entering BLOCK~%")
    (bar #'(lambda () (return-from a)))
    (format t " Leaving BLOCK~%"))
  (format t "Leaving foo~%"))
\end{myverb}

Анонимная функция, переданная \lstinline{bar} использует \lstinline{RETURN-FROM} для выхода из
\lstinline{BLOCK}. Но это выражение \lstinline{RETURN-FROM} не будет вычислено до тех пор, пока
анонимная функция не будет выполнена с помощью \lstinline{FUNCALL} или \lstinline{APPLY}. Теперь
предположим, что \lstinline{bar} выглядит следующим образом:

\begin{myverb}
(defun bar (fn)
  (format t "  Entering bar~%")
  (baz fn)
  (format t "  Leaving bar~%"))
\end{myverb}

Все равно анонимная функция не будет вызвана. Теперь посмотрим на \lstinline{baz}.

\begin{myverb}
(defun baz (fn)
  (format t "   Entering baz~%")
  (funcall fn)
  (format t "   Leaving baz~%"))
\end{myverb}

И в заключение функция выполняется. Но к чему приведёт вызов \lstinline{RETURN-FROM} из блока,
который находится на несколько уровней выше по стеку? На поверку все работает отлично~--
стек отматывается к той точке, где \lstinline{BLOCK} был создан, и контроль возвращается из
соответствующего выражения \lstinline{BLOCK}. Вызовы \lstinline{FORMAT} в функциях \lstinline{foo},
\lstinline{bar} и \lstinline{baz} демонстрируют это:

\begin{myverb}
CL-USER> (foo)
Entering foo
 Entering BLOCK
  Entering bar
   Entering baz
Leaving foo
NIL
\end{myverb}

Заметьте, что единственным выдаваемым сообщением \lstinline{Leaving . . .} является то, которое
было вставлено после выражения \lstinline{BLOCK} в функции \lstinline{foo}.

Поскольку имена блоков имеют лексическую область видимости, \lstinline{RETURN-FROM} всегда
возвращается из наименьшего охватывающего блока \lstinline{BLOCK} в лексическом окружении, в
котором задана форма \lstinline{RETURN-FROM}, даже если \lstinline{RETURN-FROM} выполняется в
отличающемся динамическом контексте. Например, \lstinline{bar} также может содержать форму
\lstinline{BLOCK} с именем~\lstinline{a}, например вот так:

\begin{myverb}
(defun bar (fn)
  (format t "  Entering bar~%")
  (block a (baz fn))
  (format t "  Leaving bar~%"))
\end{myverb}

Это дополнительное выражение \lstinline{BLOCK} никак не изменит поведение \lstinline{foo}~-- поиск
имён, таких как \lstinline{a}, производится лексически, во время компиляции, а не динамически,
так что дополнительный блок не влияет на работу \lstinline{RETURN-FROM}. И наборот, имя
\lstinline{BLOCK} может быть использовано только тем выражением \lstinline{RETURN-FROM}, которое
задано внутри лексической области видимости выражения \lstinline{BLOCK}; нет никакой
возможности для кода, который определён вне блока, выполнить выход из него, кроме как
выполнение замыкания, которое выполнит \lstinline{RETURN-FROM} из лексического окружения
\lstinline{BLOCK}.

\lstinline{TAGBODY} и \lstinline{GO} работают точно так же, как и \lstinline{BLOCK} и \lstinline{RETURN-FROM}.
Когда вы выполняете замыкание, которое содержит выражение \lstinline{GO}, и \lstinline{GO}
вычисляется, то стек отматывается назад к соответствующей форме \lstinline{TAGBODY} и затем
уже переходит к соответствующему тегу.

Однако имена блоков \lstinline{BLOCK} и теги \lstinline{TAGBODY} достаточно сильно отличаются от
связывания лексических переменных. Как обсуждалось в главе~\ref{ch:06}, лексические
связывания имеют неопределённый экстент (extent), что означает, что связывания не
исчезают даже после того, как связывающая форма будет возвращена. С другой стороны,
выражения \lstinline{BLOCK} и \lstinline{TAGBODY} имеют динамический экстент~-- вы можете выполнить
\lstinline{RETURN-FROM} из \lstinline{BLOCK} или \lstinline{GO} из тега \lstinline{TAGBODY}, только когда
\lstinline{BLOCK} или \lstinline{TAGBODY} находятся на стеке вызова функций. Другими словами,
замыкание, которое захватывает имя блока или тег \lstinline{TAGBODY}, может быть передано вниз
по стеку для последующего выполнения, но оно не может быть возвращено вверх по
стеку. Если вы выполните замыкание, которое будет пытаться выполнить \lstinline{RETURN-FROM} из
\lstinline{BLOCK}, после того как \lstinline{BLOCK} будет завершён, то вы получите
ошибку. Аналогично попытка выполнить \lstinline{GO} для \lstinline{TAGBODY}, которое больше не
существует, также вызовет ошибку\pclfootnote{Это достаточно разумное ограничение~-- не
  совсем понятно, что означает возвращение из формы, которая уже завершилась, если вы,
  конечно, не программист на Scheme. Scheme поддерживает продолжения (continuations)~--
  языковые конструкции, которые позволяют выполнить возврат из одной и той же функции
  более одного раза. Но по разным причинам лишь несколько языков, отличных от Scheme,
  поддерживают этот вид продолжений.}.

Маловероятно, что вам понадобится использовать \lstinline{BLOCK} и \lstinline{TAGBODY} для такого
способа раскрутки стека.  Но вы, скорее всего, будете использовать этот подход как часть
системы условий и рестартов, так что понимание того, как оно работает, поможет вам понять,
что в точности делается при запуске рестарта\footnote{Если вы относитесь к тем людям,
  которые любят знать, как что-то работает, вплоть до мелких деталей, то вы можете
  поразмышлять о том, как вы могли бы реализовать макросы системы условий и рестартов,
  используя \lstinline{BLOCK}, \lstinline{TAGBODY}, замыкания и динамические переменные.}\hspace{\footnotenegspace}.

\lstinline{CATCH} и \lstinline{THROW} являются ещё одной парой специальных операторов, которые
приводят к раскрутке стека.  Вы будете использовать эти операторы ещё реже, чем описанные
выше,~-- они являются наследием ранних версий Lisp, которые не имели в своём составе
систему условий Common Lisp.  Они не должны путаться с конструкциями \lstinline{try/catch} и
\lstinline{try/except} из таких языков, как Java и Python.

\lstinline{CATCH} и \lstinline{THROW} являются динамическими аналогами конструкций \lstinline{BLOCK} и
\lstinline{RETURN-FROM}.  Так что вы используете \lstinline{CATCH} для какого-то кода и затем
используете \lstinline{THROW} для выхода из блока \lstinline{CATCH} с возвратом указанного значения.
Разница заключается в том, что связь между \lstinline{CATCH} и \lstinline{THROW} устанавливается
динамически~-- вместо лексически ограниченного имени метка \lstinline{CATCH} является
объектом, называемым тегом catch, и любое выражение \lstinline{THROW} вычисляется внутри
динамического экстента \lstinline{CATCH}, так что <<выбрасывание>> (throws) этого объекта будет
приводить к раскрутке стека к блоку \lstinline{CATCH} и немедленному возврату.  Так
что вы можете написать новые версии функций \lstinline{foo}, \lstinline{bar} и \lstinline{baz}, используя
\lstinline{CATCH} и \lstinline{THROW} вместо \lstinline{BLOCK} и \lstinline{RETURN-FROM}:

\begin{myverb}
(defparameter *obj* (cons nil nil)) ; некоторый произвольный объект

(defun foo ()
  (format t "Entering foo~%")
  (catch *obj*
    (format t " Entering \lstinline{CATCH}~%")
    (bar)
    (format t " Leaving \lstinline{CATCH}~%"))
  (format t "Leaving foo~%"))

(defun bar ()
  (format t "  Entering bar~%")
  (baz)
  (format t "  Leaving bar~%"))

(defun baz ()
  (format t "   Entering baz~%")
  (throw *obj* nil)
  (format t "   Leaving baz~%"))
\end{myverb}

Заметьте, что нет необходимости передавать замыкание вниз по стеку~-- \lstinline{baz} может
напрямую вызвать \lstinline{THROW}.  Результат будет таким же, как и раньше.

\begin{myverb}
  CL-USER> (foo)
  Entering foo
   Entering \lstinline{CATCH}
    Entering bar
     Entering baz
  Leaving foo
  NIL
\end{myverb}

Однако \lstinline{CATCH} и \lstinline{THROW} слишком динамичные.  И в \lstinline{CATCH}, и в
\lstinline{THROW} форма, предс\-тав\-ляю\-щая тег, вычисляется, что означает, что её значение в
обоих случаях определяется во время выполнения.  Так что если некоторый код в \lstinline{bar}
присвоит новое значение \lstinline{*obj*}, то \lstinline{THROW} в \lstinline{baz} не будет пойман в том
же блоке \lstinline{CATCH}.  Это делает использование \lstinline{CATCH} и \lstinline{THROW} более тяжёлым,
чем \lstinline{BLOCK} и \lstinline{RETURN-FROM}. Единственным преимуществом версии \lstinline{foo},
\lstinline{bar} и \lstinline{baz}, которая использует \lstinline{CATCH} и \lstinline{THROW}, является то, что
нет необходимости передавать замыкание вниз по стеку для возврата из \lstinline{CATCH}~--
любой код, который выполняется внутри динамического экстента \lstinline{CATCH}, может заставить
вернуться к нему путём <<бросания>>  нужного объекта.

В~старых диалектах Lisp, в которых не было ничего подобного системе условий Common Lisp,
\lstinline{CATCH} и \lstinline{THROW} использовались для обработки ошибок.  Однако, для того чтобы
сделать её сопровождаемой, теги catch обычно были закавыченными символами, так что вы могли
понять, глядя на \lstinline{CATCH} и \lstinline{THROW}, где они будут перехвачены во время
выполнения. В~Common Lisp вы будете редко иметь нужду в использовании \lstinline{CATCH} и
\lstinline{THROW}, поскольку система условий намного более гибкая.

Последним специальным оператором, относящимся к управлению стеком вызовов, является
\lstinline{UNWIND-PROTECT}, который я вскользь упоминал раньше. \lstinline{UNWIND-PROTECT} позволяет
вам контролировать, что происходит при раскрутке стека, и быть уверенным в том, что
определённый код всегда выполняется, независимо от того, как поток выполнения покидает
область видимости \lstinline{UNWIND-PROTECT}~-- обычным способом, путём запуска рестарта или
любым другим способом, описанным в этом разделе\footnote{\lstinline{UNWIND-PROTECT} является
  эквивалентом конструкции \lstinline{try/finally} в Java и Python.}\hspace{\footnotenegspace}.  Базовая форма
\lstinline{UNWIND-PROTECT} выглядит примерно так:

\begin{myverb}
(unwind-protect protected-form
  cleanup-form*)
\end{myverb}

Сначала вычисляется одиночное выражение \lstinline{protected-form}, и затем, вне зависимости от
способа его завершения, будут вычислены выражения, заданные \lstinline{cleanup-forms}.  Если
\lstinline{protected-form} завершается нормальным образом, то его результат будет возвращён,
\lstinline{UNWIND-PROTECT} после вычисления возвратит \lstinline{cleanup-forms}. Выражения
\lstinline{cleanup-forms} вычисляются в том же самом динамическом окружении, что и
\lstinline{UNWIND-PROTECT}, так что все динамические переменные, связи, перезапуски и
обработчики условий будут доступны коду \lstinline{cleanup-forms}, так как они были видны
перед выполнением \lstinline{UNWIND-PROTECT}.

Вы редко будете использовать \lstinline{UNWIND-PROTECT} напрямую.  Наиболее часто вы его
будете использовать как основу для макросов в стиле \lstinline{WITH-}, таких как
\lstinline{WITH-OPEN-FILE}, который вычисляет произвольное количество выражений в контексте,
где они имеют доступ к некоторому ресурсу, который должен быть освобождён после того, как
все выполнено, вне зависимости от того, как выражения были завершены~-- нормальным
образом, через рестарт или любой другой нелокальный выход.  Например, если вы пишете
библиотеку для работы с базами данных, которая определяет функции \lstinline{open-connection} и
\lstinline{close-connection}, то вы можете написать вот такой макрос\footnote{На самом
  деле CLSQL, интерфейс к множеству баз данных, работающий на многих реализациях Lisp,
  предоставляет макрос с аналогичной функциональностью, имеющий имя \lstinline{with-database}.
  Домашняя страница CLSQL находится по адресу \url{http://clsql.b9.com}.}\hspace{\footnotenegspace}:

\begin{myverb}
(defmacro with-database-connection ((var &rest open-args) &body body)
  `(let ((,var (open-connection ,@open-args)))
    (unwind-protect (progn ,@body)
      (close-connection ,var))))
\end{myverb}

\noindent{}что позволяет вам писать в следующем стиле:

\begin{myverb}
(with-database-connection (conn :host "foo" :user "scott" :password "tiger")
  (do-stuff conn)
  (do-more-stuff conn))
\end{myverb}

\noindent{}и не беспокоиться о закрытии соединения к базе данных, поскольку \lstinline{UNWIND-PROTECT}
позаботится о его закрытии вне зависимости от того, что случится в теле формы
\lstinline{with-database-connection}.

\section{Множественные значения}

Еще одним свойством Common Lisp, которое я упоминал вскользь в главе~\ref{ch:11}, когда
обсуждал \lstinline{GETHASH}, является возможность возвращения множества значений из одного
выражения. Сейчас мы обсудим эту функциональность более подробно. Правда, не совсем
правильно обсуждать эту функциональность в главе про специальные операторы, поскольку данный
функционал не реализуется отдельными операторами, а глубоко интегрирован в
язык. Операторами, которые вы наиболее часто будете использовать с множественными
значениями, являются макросы и функции, а не специальные операторы.  Но базовая
возможность получения множественных значений обеспечивается специальным оператором
\lstinline{MULTIPLE-VALUE-CALL}, на основе которого построен более часто используемый макрос
\lstinline{MULTIPLE-VALUE-BIND}.

Ключом к понимаю множественных значений является тот факт, что возврат множества значений
совершенно отличается от возврата списка: если форма возвращает множество значений, то
до тех пор, пока вы не сделаете что-то специальное для их получения, все значения, кроме
первого (основного), будут игнорироваться.  Для того чтобы увидеть это отличие, рассмотрим
функцию \lstinline{GETHASH}, которая возвращает два значения: найденное значение и логическое
значение, которое равно \lstinline{NIL}, если значение не было найдено.  Если бы эти значения
возвращались в виде списка, то при каждом вызове \lstinline{GETHASH} вам требовалось бы
выделять найденное значение из списка, вне зависимости от того, нужно вам второе
возвращаемое значение или нет.  Предположим, что у вас есть хеш-таблица \lstinline{*h*},
которая содержит числа.  Если бы \lstinline{GETHASH} возвращал список, то вы бы не могли
написать что-то подобное:

\begin{myverb}
(+ (gethash 'a *h*) (gethash 'b *h*))
\end{myverb}

\noindent{}поскольку \lstinline{+} ожидает, что его аргументами будут числа, а не
списки. Но так как механизм работы с множественными значениями просто игнорирует
дополнительные возвращаемые значения, которые вам не нужны, то этот код будет работать
нормально.

Имеются два аспекта использования множественных значений~-- возврат мно\-жес\-твен\-ных
значений и получение неосновных значений, возвращаемых формами, которые возвращают
множественные значения.  Начальной точкой для возврата мно\-жес\-твен\-ных значений являются
функции \lstinline{VALUES} и \lstinline{VALUES-LIST}.  Это обычные функции, а не специальные
операторы, поскольку их параметры передаются как обычно.  \lstinline{VALUES} принимает переменное
число аргументов и возвращает их как множественные значения; \lstinline{VALUES-LIST} принимает
единственный аргумент~-- список значений,~-- и возвращает все его содержимое в виде
множественных значений.  Иначе говоря:

\begin{myverb}
  (values-list x) === (apply #'values x)
\end{myverb}

Механизм возврата множественных значений зависит от конкретной реализации, так же как и
механизм передачи аргументов функциям.  Почти все языковые конструкции, возвращающие
значения своих подвыражений, будут <<передавать>> множественные значения, возвращаемые
подвыражениями.  Так что функция, которая возвращает результат вызова \lstinline{VALUES} или
\lstinline{VALUES-LIST}, сама будет возвращать множественные значения, и то же самое будет
делать и функция, вызвавшая эту функцию, и т.~д.\footnote{Небольшой набор макросов не
  передаёт дополнительные возвращаемые значения тех выражений, которые они вычисляют.  В
  частности, макрос \lstinline{PROG1}, который вычисляет некоторое количество выражений,
  подобно \lstinline{PROGN}, но возвращает значение первого выражения, возвращает только
  основное значение.  Аналогичным образом \lstinline{PROG2}, который возвращает значение
  второго выражения, также возвращает лишь основное значение.  Специальный оператор
  \lstinline{MULTIPLE-VALUE-PROG1} является вариантом \lstinline{PROG1}, который возвращает все
  значения первого выражения.  Это небольшой недостаток, что \lstinline{PROG1} не ведёт себя
  так же, как \lstinline{MULTIPLE-VALUE-PROG1}, но ни один из них не используется достаточно
  часто, чтобы это было неудобным.  Макросы \lstinline{OR} и \lstinline{COND} также не всегда
  прозрачны для множественных значений, возвращая только основное значение определённого
  выражения.}\hspace{\footnotenegspace}.

Но когда выражение вычисляется в позиции значения, то используется только основное
значение~-- вот почему предыдущий пример с добавлением работает, как ожидается. Специальный
оператор \lstinline{MULTIPLE-VALUE-CALL} предоставляет механизм, который позволяет вам работать
с множественными значениями, возвращаемыми выражениями. \lstinline{MULTIPLE-VALUE-CALL}
аналогичен \lstinline{FUNCALL}, за тем исключением, что \lstinline{FUNCALL} является обычной
функцией и, как следствие, использует только основное значение из переданных аргументов,
в то время как \lstinline{MULTIPLE-VALUE-CALL} передаёт функции, указанной в качестве первого
аргумента, все значения, возвращённые остальными выражениями, указанными в качестве
аргументов.

\begin{myverb}
(funcall #'+ (values 1 2) (values 3 4))             ==> 4
(multiple-value-call #'+ (values 1 2) (values 3 4)) ==> 10
\end{myverb}

Но, скорее всего, вы достаточно редко будете просто передавать все значения, возвращённые
одной функцией, в другую функцию.  Скорее всего, вы захотите сохранить множественные
значения в отдельные переменные и затем что-то сделать с ними.  Макрос
\lstinline{MULTIPLE-VALUE-BIND}, с которым вы встречались в главе~\ref{ch:11}, является
наиболее часто используемым оператором для работы с множественными значениями.  В~общем
виде он выглядит вот так:

\begin{myverb}
(multiple-value-bind (variable*) values-form
  body-form*)
\end{myverb}

Выражение \lstinline{values-form} вычисляется, и множественные значения, которые возвращаются
им, присваиваются указанным переменным.  Затем вычисляются выражения \lstinline{body-forms}
при использовании указанных переменных.  Так что:

\begin{myverb}
(multiple-value-bind (x y) (values 1 2)
  (+ x y)) ==> 3
\end{myverb}

Другой макрос~-- \lstinline{MULTIPLE-VALUE-LIST}, ещё более простой~-- он принимает одно
выражение, вычисляет его и собирает полученные множественные значения в список.  Другими
словами, этот макрос выполняет действия, обратные действию \lstinline{VALUES-LIST}.

\begin{myverb}
CL-USER> (multiple-value-list (values 1 2))
(1 2)
CL-USER> (values-list (multiple-value-list (values 1 2)))
1
2
\end{myverb}

Однако если вы обнаружите, что часто используете \lstinline{MULTIPLE-VALUE-LIST}, то это может
быть сигналом того, что некоторая функция должна возвращать список, а не мно\-жес\-твенные
значения.

И в заключение если вы хотите присвоить множественные значения, возвращённые формой,
существующим переменным, то вы можете использовать функцию \lstinline{VALUES} для выполнения
\lstinline{SETF}.  Например:

\begin{myverb}
CL-USER> (defparameter *x* nil)
*X*
CL-USER> (defparameter *y* nil)
*Y*
CL-USER> (setf (values *x* *y*) (floor (/ 57 34)))
1
23/34
CL-USER> *x*
1
CL-USER> *y*
23/34
\end{myverb}

\section{EVAL-WHEN}

Еще одним специальным оператором, принципы работы которого вам нужно понимать, для того
чтобы писать некоторые виды макросов, является \lstinline{EVAL-WHEN}.  По некоторым
причинам книги о Lisp часто считают \lstinline{EVAL-WHEN} орудием только для экспертов.
Но единственным требованием для понимания \lstinline{EVAL-WHEN} является понимание того,
как взаимодействуют две функции~-- \lstinline{LOAD} и \lstinline{COMPILE-FILE}.  И
понимание принципов работы \lstinline{EVAL-WHEN} будет важным для вас, когда вы начнёте
писать сложные макросы, такие как те, которые мы будем писать в главах~\ref{ch:24}
и~\ref{ch:31}.

В~предыдущих главах я немного касался вопросов совместной работы \lstinline{LOAD} и
\lstinline{COMPILE-FILE}, но стоит рассмотреть этот вопрос снова.  Задачей \lstinline{LOAD} являются
загрузка файла и вычисление всех выражений верхнего уровня, содержащихся в нем.  Задачей
\lstinline{COMPILE-FILE} является компиляция исходного текста в файл FASL, который может быть
затем загружен с помощью \lstinline{LOAD}, так что \lstinline{(load "foo.lisp")} и 
\lstinline{(load "foo.fasl")} являются практически эквивалентными.

Поскольку \lstinline{LOAD} вычисляет каждое выражение до чтения следующего, побочный эффект
вычисления выражений, находящихся ближе к началу файла, может воздействовать на то, как
будут читаться и вычисляться формы, находящиеся дальше в файле.  Например, вычисление
выражения \lstinline{IN-PACKAGE} изменяет значение переменной \lstinline{*PACKAGE*}, что затронет
процедуру чтения всех остальных выражений\footnote{Причиной того, что загрузка файла с
  выражением \lstinline{IN-PACKAGE} в нем не имеет никакого влияния на значение
  \lstinline{*PACKAGE*} после возврата из \lstinline{LOAD}, является то, что \lstinline{LOAD} связывает
  \lstinline{*PACKAGE*} со своим текущим значением до того, как сделать что-то иное.  Говоря
  другими словами, что-то подобное следующему выражению \lstinline{LET} окружает остальной код
  в реализации \lstinline{LOAD}:

\begin{myverb}
(let ((*package* *package*)) ...)
\end{myverb}

Любые изменения \lstinline{*PACKAGE*} будут применяться к новой привязке, а старая привязка
будет восстановлена при выходе из \lstinline{LOAD}.  Аналогичным образом эта функция связывает
переменную \lstinline{*READTABLE*}, которую мы ещё не обсуждали.}\hspace{\footnotenegspace}.  Аналогичным образом
выражение \lstinline{DEFMACRO}, находящееся раньше в файле, может определить макрос, который
будет использоваться кодом, находящимся далее в файле\footnote{В~некоторых реализациях вы
  можете избежать вычисления \lstinline{DEFUN}, которые используют
  неопределённые макросы в теле функции, поскольку макросы определяются до того, как
  функция будет вызвана.  Но это будет работать только в тех случаях, когда вы загружаете
  определения с помощью \lstinline{LOAD} из файла с исходным кодом, но не компилируете с
  помощью \lstinline{COMPILE-FILE}, так что, в общем, определения макросов должны быть вычислены
  до того, как они будут использованы.}\hspace{\footnotenegspace}.

С другой стороны, \lstinline{COMPILE-FILE} обычно не вычисляет выражения в процессе компиляции;
это происходит в момент загрузки файла FASL. Однако \lstinline{COMPILE-FILE} должен вычислять
некоторые выражения, такие как \lstinline{IN-PACKAGE} и \lstinline{DEFMACRO}, чтобы поведение
\lstinline{(load "foo.lisp")} и \lstinline{(load "foo.fasl")} было консистентным.

Так как же работают макросы, такие как \lstinline{IN-PACKAGE} и \lstinline{DEFMACRO}, в тех случаях,
ког\-да они обрабатываются \lstinline{COMPILE-FILE}?  В~некоторых версиях Lisp, существовавших до
разработки Common Lisp, компилятор файлов просто знал, что он должен вычислять некоторые
макросы в добавление к их компиляции.  Common Lisp избегает необходимости таких хаков
путём введения специального оператора \lstinline{EVAL-WHEN}, взятого из Maclisp.  Этот оператор,
как и предполагает его имя, позволяет контролировать то, когда определённые части кода
должны вычисляться. В~общем виде выражение \lstinline{EVAL-WHEN} выглядит вот так:

\begin{myverb}
(eval-when (situation*)
  body-form*)
\end{myverb}

Есть три возможных условия~-- \lstinline{:compile-toplevel}, \lstinline{:load-toplevel}
и \lstinline{:execute}, и то, которое вы укажете, будет определять то, когда будут вычислены
выражения, указанные \lstinline{body-forms}.  \lstinline{EVAL-WHEN} с несколькими условиями
аналогичен записи нескольких выражений \lstinline{EVAL-WHEN} с разными условиями, но с
одинаковыми выражениями.  Для объяснения того, что означают эти условия, нам необходимо
объяснить, что делает \lstinline{COMPILE-FILE} (который также называют компилятором файлов) в
процессе компиляции файла.

Для того чтобы объяснить, как \lstinline{COMPILE-FILE} компилирует выражения
\lstinline{EVAL-WHEN}, я должен описать отличия между компиляцией выражений верхнего
уровня (top-level form) и компиляцией остальных выражений.  Выражения верхнего уровня,
грубо говоря~-- это те, которые будут скомпилированы в исполняемый код, который будет
выполнен при загрузке файла FASL.  Так что все выражения, которые находятся на верхнем
уровне файла с исходным текстом, будут скомпилированы как выражения верхнего
уровня. Аналогичным образом все выражения, указанные в выражении \lstinline{PROGN}
верхнего уровня, будут также скомпилированы как выражения верхнего уровня
(\lstinline{PROGN} сам ничего не делает~-- он лишь группирует вместе указанные выражения),
и они будут выполнены при загрузке FASL\footnote{В~противоположность этому выражения,
  указанные в \lstinline{LET} верхнего уровня, не будут скомпилированы как выражения
  верхнего уровня, потому что они не будут выполняться при загрузке FASL.  Они будут
  выполнены в контексте привязок, созданных \lstinline{LET}. Теоретически \lstinline{LET},
  не связывающий никаких переменных, может рассматриваться как \lstinline{PROGN}, но это не
  так~-- выражения, указанные в \lstinline{LET}, никогда не будут считаться выражениями
  верхнего уровня.}\hspace{\footnotenegspace}.  Аналогичным образом выражения, указанные в \lstinline{MACROLET} или
\lstinline{SYMBOL-MACROLET}, будут скомпилированы как выражения верхнего уровня, поскольку
после того, как компилятор раскроет локальные и символьные макросы, в скомпилированном
коде не останется никаких упоминаний \lstinline{MACROLET} или \lstinline{SYMBOL-MACROLET}.
И в заключение раскрытие макроса верхнего уровня будет скомпилировано как выражение
верхнего уровня.

Таким образом, \lstinline{DEFUN}, указанный на верхнем уровне исходного текста, является
выражением верхнего уровня~-- код, который определяет функцию и связывает её с именем,
будет выполнен при загрузке FASL, но выражения внутри тела функции, которые не будут
выполнены до тех пор, пока функция не будет вызвана, не являются вы\-ра\-же\-ния\-ми верхнего
уровня.  Большинство выражений компилируется одинаково вне зависимости от того, на верхнем
они уровне или нет, но семантика выражения \lstinline{EVAL-WHEN} зависит от того, будет ли
оно скомпилировано как выражение верхнего уровня, выражение неверхнего уровня или просто
вычислено, и все это в комбинации с условиями, указанными в выражении.

Условия \lstinline{:compile-toplevel} и \lstinline{:load-toplevel} контролируют поведение
\lstinline{EVAL-WHEN}, которое компилируется как выражение верхнего уровня.  Когда присутствует
условие \lstinline{:compile-toplevel}, то компилятор файла вычислит заданные выражения во время
компиляции.  Когда указано условие \lstinline{:load-toplevel}, то он будет компилировать
выражения как выражения верхнего уровня.  Если ни одно из этих условий не указано в
выражении \lstinline{EVAL-WHEN} верхнего уровня, то компилятор просто игнорирует его.

Когда \lstinline{EVAL-WHEN} компилируется как выражение не верхнего уровня, то он либо
компилируется как \lstinline{PROGN}, в том случае если указано условие
\lstinline{:execute}, либо просто игнорируется.  Аналогичным образом вычисляемое
выражение \lstinline{EVAL-WHEN} (что включает в себя выражения \lstinline{EVAL-WHEN}
верхнего уровня в исходном тексте, обрабатываемом \lstinline{LOAD}, и
\lstinline{EVAL-WHEN}, вычисляемый во время компиляции, когда он является подвыражением
другого \lstinline{EVAL-WHEN} с условием \lstinline{:compile-toplevel}) также
рассматривается как \lstinline{PROGN}, если указано условие \lstinline{:execute}, и
игнорируется в противном случае.

Таким образом, макрос, такой как \lstinline{IN-PACKAGE}, может производить необходимые действия
и во время компиляции, и при загрузке из исходного кода путём раскрытия в выражения
\lstinline{EVAL-WHEN}, выглядящие примерно так:

\begin{myverb}
(eval-when (:compile-toplevel :load-toplevel :execute)
  (setf *package* (find-package "PACKAGE-NAME")))
\end{myverb}

Значение \lstinline{*PACKAGE*} будет выставлено во время компиляции из-за условия
\lstinline{:compile-toplevel}, во время загрузки FASL из-за условия \lstinline{:load-toplevel} и во
время загрузки исходного кода из-за условия \lstinline{:execute}.

Существуют два широко распространённых способа использования \lstinline{EVAL-WHEN}. Первый~--
если вы хотите написать макрос, которому необходимо сохранить некоторую информацию во
время компиляции и которая будет использоваться при генерации раскрытий других
макровыражений в том же файле.  Это обычно нужно для определяющих (definitional)
макросов, когда определение, расположенное в начале файла, может влиять на код,
генерируемый для определения, расположенного далее в том же файле.  Вы будете писать такие
макросы в главе~\ref{ch:24}.

Вам также может понадобиться использовать \lstinline{EVAL-WHEN}, если вы захотите поместить
определение макроса и вспомогательной функции, которая используется в этом макросе, в том
же файле с исходным текстом, что и код, использующий данный макрос. \lstinline{DEFMACRO} уже
использует \lstinline{EVAL-WHEN} в своём раскрытии, так что определение макроса становится
доступным для использования сразу.  Но обычно \lstinline{DEFUN} не делает определение функции
доступным во время компиляции, а если вы используете макрос в том же файле, где он
определён, то вам необходимо, чтобы были определены и все функции, используемые в
макросе. Если вы обернёте все определения вспомогательных функций в выражение
\lstinline{EVAL-WHEN} с условием \lstinline{:compile-toplevel}, то определения будут доступны при
раскрытии макросов. Вы, наверное, захотите включить также условия \lstinline{:load-toplevel} и
\lstinline{:execute}, поскольку макросы будут требовать наличия определения функций после того,
как файл скомпилирован и загружен, или если вы загружаете файл с исходным текстом вместо
компиляции.

\section{Другие специальные операторы}

Все оставшиеся четыре специальных оператора~-- \lstinline{LOCALLY}, \lstinline{THE},
\lstinline{LOAD-TIME-VALUE} и \lstinline{PROGV},~-- позволяют получить доступ к некоторым
частям нижележащего языка, к которым доступ не может быть осуществлён другими способами.
\lstinline{LOCALLY} и \lstinline{THE} являются частями системы объявлений Common Lisp,
которая используется для <<связывания>> некоторых вещей с компилятором, что не изменит
работу вашего кода, но позволит генерировать лучший код~-- более быстрый, более понятные
сообщения об ошибках и т.~п\footnote{Одним из объявлений, которая имеет влияние на
  семантику программы, является объявление \lstinline{SPECIAL}, упомянутое в
  главе~\ref{ch:06}.}\hspace{\footnotenegspace}. Мы коротко обсудим объявления в
главе~\ref{ch:32}.

Еще два оператора~-- \lstinline{LOAD-TIME-VALUE} и \lstinline{PROGV},~-- используются редко, и
объяснение того, почему это происходит, займёт больше времени, чем объяснение того, что
они делают. Я расскажу вам то, что они делают, так что просто вы будете иметь эту
информацию. Когда-нибудь вы встретите один из них, и тогда вы будете готовы к пониманию их
работы.

\lstinline{LOAD-TIME-VALUE} используется (как видно из его имени) для создания значения во
время загрузки.  Когда компилятор обрабатывает код, который содержит выражение
\lstinline{LOAD-TIME-VALUE}, он генерирует код, который выполнит подвыражения лишь один раз, во
время загрузки FASL, и код, содержащий выражение \lstinline{LOAD-TIME-VALUE}, будет ссылаться на
вычисленное значение.  Другими словами, вместо того чтобы писать что-то подобное:

\begin{myverb}
(defvar *loaded-at* (get-universal-time))

(defun when-loaded () *loaded-at*)
\end{myverb}

\noindent{}вы можете просто написать вот так:

\begin{myverb}
(defun when-loaded () (load-time-value (get-universal-time)))
\end{myverb}

В~коде, не обрабатываемом \lstinline{COMPILE-FILE}, выражение \lstinline{LOAD-TIME-VALUE}
вычисляется однажды, во время компиляции, что может происходить, когда вы явно компилируете
функцию с помощью \lstinline{COMPILE}, или даже раньше, из-за неявной компиляции кода во время
его вычисления.  В~некомпилируемом коде \lstinline{LOAD-TIME-VALUE} вычисляет свои
подвыражения при каждом вычислении.

И в заключение \lstinline{PROGV} создаёт новые динамические привязки для переменных, чьи имена
определяются во время выполнения.  Это в основном полезно при реализации встраиваемых
интерпретаторов для языков с динамической областью видимости переменных.  Базовая
структура этого выражения выглядит вот так:

\begin{myverb}
(progv symbols-list values-list
  body-form*)
\end{myverb}

\noindent{}где \lstinline{symbols-list} является выражением, которое вычисляется в список символов, а
\lstinline{values-list}~-- выражение, которое вычисляется в список значений.  Каждый символ
динамически связывается с соответствующим значением, и затем вычисляются выражения,
указанные в \lstinline{body-forms}.  Разница между \lstinline{PROGV} и \lstinline{LET} заключается в том,
что \lstinline{symbols-list} вычисляется во время выполнения и имена связываемых переменных
вычисляются динамически.  Как я уже сказал, этот оператор не понадобится вам очень часто.

И это вся информация о специальных операторах.  В~следующей главе я вернусь к
практическим темам и покажу вам, как использовать пакетную систему Common Lisp для
получения контроля за пространствами имён, так что вы можете писать библиотеки и
приложения, которые смогут сосуществовать без разрушения друг друга.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "pcl-ru"
%%% TeX-open-quote: "<<"
%%% TeX-close-quote: ">>"
%%% End: 
